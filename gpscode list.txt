#include <HardwareSerial.h>

HardwareSerial mySerial(1);

void setup() {
    Serial.begin(115200);
    mySerial.begin(9600, SERIAL_8N1, 33, 32);
}

void loop() {
    if (mySerial.available()) {
        char c = mySerial.read();
        Serial.print(c); // Print raw GPS data
    } else {
        Serial.println("No GPS Data...");
        delay(1000);
    }
}
.
.
.
.
.
.
#include <HardwareSerial.h>

HardwareSerial mySerial(1); // Use UART1 for GPS

void setup() {
    Serial.begin(115200); // Serial Monitor
    mySerial.begin(9600, SERIAL_8N1, 33, 32); // GPS TX=33, RX=32

    // Send reset command
    mySerial.println("$PMTK104*37");
}

void loop() {
    while (mySerial.available()) {
        Serial.write(mySerial.read()); // Print GPS output
    }
}
.
.
.
.
.

#include <Wire.h>
#include <Adafruit_SSD1306.h>
#include <TinyGPS++.h>


#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels

//On ESP32: GPIO-21(SDA), GPIO-22(SCL)
#define OLED_RESET -1 //Reset pin # (or -1 if sharing Arduino reset pin)
#define SCREEN_ADDRESS 0x3C //See datasheet for Address
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

#define RXD2 16
#define TXD2 17
HardwareSerial neogps(1);

TinyGPSPlus gps;

void setup() {
  Serial.begin(115200);
  //Begin serial communication Arduino IDE (Serial Monitor)

  //Begin serial communication Neo6mGPS
  neogps.begin(9600, SERIAL_8N1, RXD2, TXD2);
  
  // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally
  if(!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {
    Serial.println(F("SSD1306 allocation failed"));
    for(;;); // Don't proceed, loop forever
  }

  display.clearDisplay();
  display.display();
  delay(2000);

}

void loop() {
    
  boolean newData = false;
  for (unsigned long start = millis(); millis() - start < 1000;)
  {
    while (neogps.available())
    {
      if (gps.encode(neogps.read()))
      {
        newData = true;
      }
    }
  }

  //If newData is true
  if(newData == true)
  {
    newData = false;
    Serial.println(gps.satellites.value());
    print_speed();
  }
  else
  {
    display.clearDisplay();
    display.setTextColor(SSD1306_WHITE);
    display.setCursor(0, 0);
    display.setTextSize(3);
    display.print("No Data");
    display.display();
  }  
  
}

void print_speed()
{
  display.clearDisplay();
  display.setTextColor(SSD1306_WHITE);
       
  if (gps.location.isValid() == 1)
  {
   //String gps_speed = String(gps.speed.kmph());
    display.setTextSize(1);
    
    display.setCursor(25, 5);
    display.print("Lat: ");
    display.setCursor(50, 5);
    display.print(gps.location.lat(),6);

    display.setCursor(25, 20);
    display.print("Lng: ");
    display.setCursor(50, 20);
    display.print(gps.location.lng(),6);

    display.setCursor(25, 35);
    display.print("Speed: ");
    display.setCursor(65, 35);
    display.print(gps.speed.kmph());
    
    display.setTextSize(1);
    display.setCursor(0, 50);
    display.print("SAT:");
    display.setCursor(25, 50);
    display.print(gps.satellites.value());

    display.setTextSize(1);
    display.setCursor(70, 50);
    display.print("ALT:");
    display.setCursor(95, 50);
    display.print(gps.altitude.meters(), 0);

    display.display();
    
  }
  else
  {
    display.clearDisplay();
    display.setTextColor(SSD1306_WHITE);
    display.setCursor(0, 0);
    display.setTextSize(3);
    display.print("No Data");
    display.display();
  }  

}
.
.
.
.
.#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <vector>

const char* ssid = "Prithviraj";
const char* password = "PrithviraJK123";
const char* serverUrl = "https://www.circuitdigest.cloud/geolinker";
const char* apiKey = "3xiB1qOLiExJ";

HardwareSerial gpsSerial(1);
const int RXPin = 33; // Bharat Pi NavIC GPS TX -> ESP32 RX
const int TXPin = 32; // Bharat Pi NavIC GPS RX -> ESP32 TX

struct GPSData {
    double latitude;
    double longitude;
    String timestamp;
};

const unsigned long uploadInterval = 10000;
unsigned long lastUploadTime = 0;

bool gpsDataValid = false;
GPSData latestGPSData;
std::vector<GPSData> offlineData;

void setup() {
    Serial.begin(115200);
    gpsSerial.begin(115200, SERIAL_8N1, RXPin, TXPin);
    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED) {
        delay(500);
        Serial.print(".");
    }
    Serial.println("\nWiFi connected!");
}

void loop() {
    static String gpsData = "";
    while (gpsSerial.available()) {
        char c = gpsSerial.read();
        gpsData += c;
        if (c == '\n') {
            processGPSData(gpsData);
            gpsData = "";
        }
    }
    
    if (millis() - lastUploadTime >= uploadInterval) {
        lastUploadTime = millis();
        if (gpsDataValid) {
            if (WiFi.status() == WL_CONNECTED) {
                for (auto& data : offlineData) {
                    if (!sendGPSData(data)) return;
                }
                offlineData.clear();
                if (!sendGPSData(latestGPSData)) offlineData.push_back(latestGPSData);
            } else {
                offlineData.push_back(latestGPSData);
                WiFi.disconnect();
                WiFi.reconnect();
            }
        }
    }
}

bool sendGPSData(GPSData data) {
    HTTPClient http;
    http.begin(serverUrl);
    http.addHeader("Content-Type", "application/json");
    http.addHeader("Authorization", apiKey);
    
    String payload = "{";
    payload += "\"timestamp\": \"" + data.timestamp + "\",";
    payload += "\"lat\": " + String(data.latitude, 6) + ",";
    payload += "\"long\": " + String(data.longitude, 6) + "}";
    
    int httpResponseCode = http.POST(payload);
    http.end();
    return (httpResponseCode == 200 || httpResponseCode == 201);
}

void processGPSData(String raw) {
    if (raw.startsWith("$GPGGA")) {
        parseGPGGA(raw);
    } else if (raw.startsWith("$GPRMC")) {
        parseGPRMC(raw);
    }
}

void parseGPGGA(String gpgga) {
    String tokens[15];
    int tokenIndex = 0, startIndex = 0;
    for (int i = 0; i < gpgga.length(); i++) {
        if (gpgga[i] == ',' || gpgga[i] == '*') {
            tokens[tokenIndex++] = gpgga.substring(startIndex, i);
            startIndex = i + 1;
        }
    }
    if (tokenIndex > 1) {
        latestGPSData.latitude = nmeaToDecimal(tokens[2]);
        latestGPSData.longitude = nmeaToDecimal(tokens[4]);
        gpsDataValid = (latestGPSData.latitude != 0 || latestGPSData.longitude != 0);
    }
}

void parseGPRMC(String gprmc) {
    String tokens[15];
    int tokenIndex = 0, startIndex = 0;
    for (int i = 0; i < gprmc.length(); i++) {
        if (gprmc[i] == ',' || gprmc[i] == '*') {
            tokens[tokenIndex++] = gprmc.substring(startIndex, i);
            startIndex = i + 1;
        }
    }
    if (tokenIndex > 9) {
        latestGPSData.timestamp = "20" + tokens[9].substring(4, 6) + "-" + tokens[9].substring(2, 4) + "-" + tokens[9].substring(0, 2);
    }
}

double nmeaToDecimal(String nmeaCoord) {
    if (nmeaCoord == "") return 0.0;
    double raw = nmeaCoord.toDouble();
    int degrees = int(raw / 100);
    double minutes = raw - (degrees * 100);
    return degrees + (minutes / 60.0);
}
.
.
.
.
.
.
#include <TinyGPS++.h>
#include <HardwareSerial.h>

#define GPS_RX_PIN 33
#define GPS_TX_PIN 32

TinyGPSPlus gps;
HardwareSerial gpsSerial(1);

void setup() {
    Serial.begin(115200);
    gpsSerial.begin(115200, SERIAL_8N1, GPS_RX_PIN, GPS_TX_PIN);
    delay(5000);
    
    Serial.println("\n\n**********************************************************************************");
    Serial.println("  Bharat Pi NavIC Shield Test Program");
    Serial.println("  Please wait while the NavIC module latches to satellites...");
    Serial.println("  IMPORTANT: Ensure that the antenna has sky visibility.");
    Serial.println("**********************************************************************************\n");

    // Send Reset Command to GPS
    Serial.println("Sending GPS Reset Command...");
    gpsSerial.println("$PMTK104*37");
    delay(2000);  // Wait for GPS to reset
}

void loop() {
    // Check if GPS is sending raw data
    while (gpsSerial.available()) {
        char c = gpsSerial.read();
        Serial.write(c); // Print raw GPS data
        if (gps.encode(c)) {
            if (gps.location.isValid()) {
                Serial.println("\nGPS Data Received!");
                Serial.print("Lat: ");
                Serial.println(gps.location.lat(), 7);
                Serial.print("Long: ");
                Serial.println(gps.location.lng(), 7);
                Serial.print("Satellites: ");
                Serial.println(gps.satellites.value());
                Serial.println("------------------------------------\n");
            }
        }
    }

    delay(1000);
    Serial.println("No GPS Data... Checking again.");
}
.
.
.
.
..
.
#include <WiFi.h>
#include <ThingSpeak.h>
#include <TinyGPS++.h>

const char* ssid = "Prithviraj";           // Your WiFi SSID
const char* password = "PrithviraJK123";     // Your WiFi Password

unsigned long channelID = 2893841;  // Your Channel ID
const char* writeAPIKey = "OH3ZGPCMR7IK4U58";  // Your Write API Key

WiFiClient client;
TinyGPSPlus gps;
HardwareSerial mySerial(1);  // Use UART1 for GPS

float latitude = 0.0;
float longitude = 0.0;

void setup() {
    Serial.begin(115200);

    Serial.print("Connecting to WiFi...");
    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED) {
        delay(500);
        Serial.print(".");
    }
    Serial.println("\nConnected to WiFi!");

    ThingSpeak.begin(client);
    mySerial.begin(9600, SERIAL_8N1, 33, 32);  // GPS RX = GPIO33, TX = GPIO32
}

void loop() {
    readGPS();
    sendDataToThingSpeak();
    delay(10000);  // Send data every 10 seconds
}

void readGPS() {
    while (mySerial.available() > 0) {
        gps.encode(mySerial.read());
    }

    if (gps.location.isValid()) {
        latitude = gps.location.lat();
        longitude = gps.location.lng();
        Serial.print("Latitude: "); Serial.print(latitude, 6);
        Serial.print(" Longitude: "); Serial.println(longitude, 6);
    } else {
        Serial.println("Waiting for GPS fix...");
    }
}

void sendDataToThingSpeak() {
    if (!gps.location.isValid()) {
        Serial.println("No valid GPS data, skipping update.");
        return;
    }

    ThingSpeak.setField(1, latitude);
    ThingSpeak.setField(2, longitude);

    int httpResponseCode = ThingSpeak.writeFields(channelID, writeAPIKey);
    Serial.print("ThingSpeak Response: ");
    Serial.println(httpResponseCode);

    if (httpResponseCode == 200) {
        Serial.println("‚úÖ Location data sent successfully.");
    } else {
        Serial.println("‚ùå Error sending data. Check WiFi and API key.");
    }
}



/*************************************************************************
   PROJECT NAME:  Bharat Pi NavIC Shield test firmware 
   AUTHOR: Bharat Pi
   CREATED DATE: 26/03/2024
   COPYRIGHT: BharatPi @MIT license for usage on Bharat Pi boards
   VERSION: 2.0

   DESCRIPTION: NavIC get latlong and other navigation parameters using Bharat Pi NavIC tracker shield.

   REVISION HISTORY TABLE:
   ------------------------------------------
   Date      | Firmware Version | Comments
   ------------------------------------------
   26/03/2024 -    1.0       -    Initial release with Lat long and other nav parameters. Prints to serial monitor.
   05/08/2024 -    2.0       -    Switched to Hardware serial as the software serial had issues with baud rates,
                             -    Added Google maps link so that lat long can be viewed from URL printed on serial monitor

 *************************************************************************/

#include <TinyGPS++.h> //Lib version compatible - 1.0.3
#include <HardwareSerial.h> //This is available from ESP32 itself not an external lib so we are good here.


#define GPS_RX_PIN 33
#define GPS_TX_PIN 32 


TinyGPSPlus gps;
HardwareSerial gpsSerial(1);


void setup() {
    Serial.begin(115200);  
    gpsSerial.begin(115200, SERIAL_8N1, GPS_RX_PIN, GPS_TX_PIN); 
    delay(5000);
    Serial.println();
    Serial.println();
    Serial.println();
    Serial.println();
    Serial.println("");
    Serial.println("  Bharat Pi NavIC Shield Test Program\n  You can use the NavIC shield on any Bharat Pi boards.\n");
    Serial.println("  Please wait while the NavIC module latches to satellites.\n");
    Serial.println("  You will notice the \"Red LED\" (PPS) on NavIC shield blinking once it latches.\n\n");
    Serial.println("  IMPORTANT: Ensure that the antenna has sky visibility and its not cloudy else it may not latch.");
    Serial.println("");
    Serial.println();
    Serial.println();
    Serial.println("  Awaiting for NavIC satellite signal latching...");
    Serial.println();
    Serial.println();
}


void loop() {
    // Read data from GPS module
    while (gpsSerial.available() > 0) {
        if (gps.encode(gpsSerial.read())) {
            if (gps.location.isValid()) {
                // Get latitude and longitude
                float latitude = gps.location.lat();
                float longitude = gps.location.lng();
                String  date = gps.date.day() + "/" + gps.date.month();
                String time = gps.time.hour() + ":" + gps.time.minute();
                double speedKnots = gps.speed.knots();
                float  courseDeg = gps.course.deg();
                double altitudeMts = gps.altitude.meters();
                uint32_t satellites = gps.satellites.value();
                double hdop = gps.hdop.hdop();
// Print latitude and longitude, you can uncommment other parameter if you like to view those as well like date/time etc.
                Serial.print("Lat: ");
                Serial.println(latitude, 7);
                Serial.print("Long: ");
                Serial.println(longitude, 7);
                Serial.print("View lat long on Google Maps ===>>> ");
                Serial.println("http://maps.google.com/maps?q=" + String(latitude, 7) + "," + String(longitude, 7));
                // Serial.print("Date: ");
                // Serial.println(date);
                // Serial.print("Time: ");
                // Serial.println(time);
                Serial.print("Speed (knots): ");
                Serial.println(speedKnots, 7);                                                
                Serial.print("Course (degree): ");
                Serial.println(courseDeg, 7);
                Serial.print("Altitude (Meters): ");
                Serial.println(altitudeMts, 7);    
                Serial.print("Satellites:");
                Serial.println(satellites, 7);  
                Serial.print("HDOP:");
                Serial.println(hdop, 7);    
                Serial.println();
                Serial.println();                                                            
            }
        }
    }
}
.
.
.
.
.
.
..
#define RX_PIN 32
#define TX_PIN 33
HardwareSerial GPS_Serial(1);  // Using UART1

void setup() {
    Serial.begin(115200);
    GPS_Serial.begin(9600, SERIAL_8N1, RX_PIN, TX_PIN);
    Serial.println("Reading GPS data from UART1 (RX:32, TX:33)");
}

void loop() {
    if (GPS_Serial.available()) {
        String gpsData = "";
        while (GPS_Serial.available()) {
            char c = GPS_Serial.read();
            gpsData += c;
        }
        Serial.print(gpsData);
    }
}
..
.
.
.
.
.
.
.
#define RX_PIN 16
#define TX_PIN 17
HardwareSerial GPS_Serial(2);  // Using UART2

void setup() {
    Serial.begin(115200);
    GPS_Serial.begin(9600, SERIAL_8N1, RX_PIN, TX_PIN);
    Serial.println("Reading GPS data from UART2 (RX:16, TX:17)");
}

void loop() {
    if (GPS_Serial.available()) {
        String gpsData = "";
        while (GPS_Serial.available()) {
            char c = GPS_Serial.read();
            gpsData += c;
        }
        Serial.print(gpsData);
    }
}
.
.

.
.
.
.
.
#define RX_PIN 14
#define TX_PIN 15
HardwareSerial GPS_Serial(2);  // Using UART3

void setup() {
    Serial.begin(115200);
    GPS_Serial.begin(9600, SERIAL_8N1, RX_PIN, TX_PIN);
    Serial.println("Reading GPS data from UART3 (RX:14, TX:15)");
}

void loop() {
    if (GPS_Serial.available()) {
        String gpsData = "";
        while (GPS_Serial.available()) {
            char c = GPS_Serial.read();
            gpsData += c;
        }
        Serial.print(gpsData);
    }
}
.
.

.
.
.
.
.
#include <HardwareSerial.h>

HardwareSerial simcom(1); // Use UART1 for SIMCOM A7672S

void setup() {
    Serial.begin(115200);   
    simcom.begin(115200, SERIAL_8N1, 27, 26); // TX = GPIO27, RX = GPIO26

    Serial.println("Initializing GPS...");
    delay(1000);

    simcom.println("AT"); // Check if SIMCOM module is responding
    delay(1000);
    printResponse();

    simcom.println("AT+CGNSPWR=1"); // Enable GPS
    delay(2000);
    printResponse();
}

void loop() {
    Serial.println("Fetching GPS Location...");
    simcom.println("AT+CGNSINF"); // Fetch GPS Data
    delay(2000);
    printResponse();

    delay(5000); // Wait 5 sec before next request
}

void printResponse() {
    while (simcom.available()) {
        Serial.write(simcom.read()); 
    }
    Serial.println();
}
.
.
.
.
.
üì¢ If GPS is Not Working
Make sure your antenna is connected securely.

Try swapping TX and RX pins ‚Üí (27, 26) ‚Üî (26, 27).

Test manually: Open the Serial Monitor and type:

AT ‚Üí Should return OK.

AT+CGNSPWR=1 ‚Üí Should return OK.

AT+CGNSINF ‚Üí Should return GPS coordinates.
.
.
.
.
.
.
.
.
.
(Bharat pi on board gps tracking)


#include <HardwareSerial.h>

HardwareSerial simcom(1);  // Use UART1 for SIMCOM

void setup() {
    Serial.begin(115200);
    simcom.begin(115200, SERIAL_8N1, 27, 26);  // Adjust baud rate if necessary

    Serial.println("Testing SIMCOM Module...");
    delay(1000);

    Serial.println("Sending AT command...");
    simcom.println("AT");  // Send AT command
    delay(2000);
    Serial.println("Checking for response...");
    printResponse();  // Read and print response
}

void loop() {
    // Keep checking for any response
    printResponse();
}

void printResponse() {
    while (simcom.available()) {
        Serial.write(simcom.read());  // Print SIMCOM response
    }
}
.
.
.
.
#include <HardwareSerial.h>

HardwareSerial simcom(1);  // Use UART1 for SIMCOM

void setup() {
    Serial.begin(115200);
    simcom.begin(115200, SERIAL_8N1, 27, 26);  // Adjust baud rate if necessary

    Serial.println("Testing SIMCOM Module...");
    delay(1000);

    // Enable GPS
    Serial.println("Enabling GPS...");
    simcom.println("AT+CGPS=1");
    delay(2000);
    printResponse();  // Read and print response

    // Get GPS location
    Serial.println("Getting GPS location...");
    simcom.println("AT+CGPSINFO");
    delay(2000);
    printResponse();  // Read and print response
}

void loop() {
    // Keep checking for any response
    printResponse();
}

void printResponse() {
    while (simcom.available()) {
        Serial.write(simcom.read());  // Print SIMCOM response
    }
}
.
.
.
.
.
#include <HardwareSerial.h>

HardwareSerial simcom(1);  // Use UART1 for SIMCOM

void setup() {
    Serial.begin(115200);
    simcom.begin(115200, SERIAL_8N1, 27, 26);  // Adjust baud rate if necessary

    Serial.println("Testing SIMCOM Module...");
    delay(1000);

    // Enable GPS
    Serial.println("Enabling GPS...");
    simcom.println("AT+CGPS=1");
    delay(2000);
    printResponse();  // Read and print response

    // Get GPS location
    Serial.println("Getting GPS location...");
    simcom.println("AT+CGPSINFO");
    delay(2000);
    printResponse();  // Read and print response
}

void loop() {
    // Keep checking for any response
    printResponse();
}

void printResponse() {
    while (simcom.available()) {
        Serial.write(simcom.read());  // Print SIMCOM response
    }
}
.
.
.
.
.
#include <TinyGPSPlus.h>
#include <HardwareSerial.h>

HardwareSerial simcom(1);  // Use UART1 for SIMCOM
TinyGPSPlus gps;

void setup() {
    Serial.begin(115200);  // Serial monitor
    simcom.begin(115200, SERIAL_8N1, 27, 26);  // Adjust baud rate and pins as necessary

    Serial.println("Initializing GPS...");
    delay(1000);

    // Enable GPS
    simcom.println("AT+CGPS=1");
    delay(2000);
    printResponse();  // Read and print response
}

void loop() {
    while (simcom.available()) {
        // Read data from the SIMCOM module
        char c = simcom.read();
        gps.encode(c);  // Feed the character to the GPS parser

        // If a new GPS fix is available, print the data
        if (gps.location.isUpdated()) {
            Serial.print("Latitude: ");
            Serial.print(gps.location.lat(), 6);  // Print latitude with 6 decimal places
            Serial.print(" Longitude: ");
            Serial.println(gps.location.lng(), 6);  // Print longitude with 6 decimal places
        }

        // Optionally, print other GPS data
        if (gps.date.isUpdated()) {
            Serial.print("Date: ");
            Serial.print(gps.date.day());
            Serial.print("/");
            Serial.print(gps.date.month());
            Serial.print("/");
            Serial.println(gps.date.year());
        }

        if (gps.time.isUpdated()) {
            Serial.print("Time: ");
            Serial.print(gps.time.hour());
            Serial.print(":");
            Serial.print(gps.time.minute());
            Serial.print(":");
            Serial.println(gps.time.second());
        }

        if (gps.altitude.isUpdated()) {
            Serial.print("Altitude: ");
            Serial.print(gps.altitude.meters());
            Serial.println(" m");
        }

        if (gps.speed.isUpdated()) {
            Serial.print("Speed: ");
            Serial.print(gps.speed.kmph());
            Serial.println(" km/h");
        }
    }
}

void printResponse() {
    while (simcom.available()) {
        Serial.write(simcom.read());  // Print SIMCOM response
    }
}
.
.
.
.
.
#include <TinyGPS++.h>
#include <Adafruit_GPS.h>
#include <NMEAGPS.h>
#include <HardwareSerial.h>

#define RXD2 33  // GPS TX pin connected to Bharat Pi GPIO33 (RX)
#define TXD2 32  // GPS RX pin connected to Bharat Pi GPIO32 (TX)
#define GPS_BAUD 9600

TinyGPSPlus gps;           // TinyGPS++ instance
HardwareSerial gpsSerial(2); // Use Serial2 for Bharat Pi

void setup() {
    Serial.begin(115200);  // Serial Monitor
    gpsSerial.begin(GPS_BAUD, SERIAL_8N1, RXD2, TXD2);
    Serial.println("Bharat Pi NavIC GPS Tracking Started...");
}

void loop() {
    while (gpsSerial.available()) {
        char c = gpsSerial.read();
        if (gps.encode(c)) {  // Parse GPS data
            if (gps.location.isUpdated()) {
                Serial.print("Latitude: ");
                Serial.println(gps.location.lat(), 6);
                Serial.print("Longitude: ");
                Serial.println(gps.location.lng(), 6);
            }
        }
    }
}
.
.
.
.
.
/*
 * Bharat Pi GPS with NAVIC Support - Fixed Version
 * Uses TinyGPS++ library
 * 
 * Hardware:
 * - Bharat Pi board
 * - GPS module with NAVIC support (e.g., NEO-M8N)
 * 
 * Connections:
 * - GPS TX to Bharat Pi RX (GPIO16)
 * - GPS RX to Bharat Pi TX (GPIO17) - optional
 * - GPS VCC to 3.3V
 * - GPS GND to GND
 */

#include <TinyGPS++.h>
#include <HardwareSerial.h>

// Bharat Pi hardware serial pins for GPS
#define GPS_RX 16  // Connect to GPS TX
#define GPS_TX 17  // Connect to GPS RX (optional)

HardwareSerial gpsSerial(1);  // Using UART1 on Bharat Pi
TinyGPSPlus gps;

void setup() {
  Serial.begin(115200);
  gpsSerial.begin(9600, SERIAL_8N1, GPS_RX, GPS_TX);
  
  Serial.println("Bharat Pi GPS with NAVIC Support");
  Serial.println("Initializing GPS...");
  
  // Optional: Configure GPS to enable NAVIC/IRNSS
  // enableNAVIC();
  
  delay(1000);
}

void loop() {
  while (gpsSerial.available() > 0) {
    if (gps.encode(gpsSerial.read())) {
      displayGPSInfo();
    }
  }

  if (millis() > 5000 && gps.charsProcessed() < 10) {
    Serial.println("No GPS detected - check wiring");
    while(true);
  }
}

void displayGPSInfo() {
  // Location data
  Serial.print("Location: ");
  if (gps.location.isValid()) {
    Serial.print(gps.location.lat(), 6);
    Serial.print(", ");
    Serial.print(gps.location.lng(), 6);
    Serial.print("  Altitude: ");
    if (gps.altitude.isValid()) Serial.print(gps.altitude.meters()); else Serial.print("INVALID");
  } else {
    Serial.print("INVALID");
  }

  // Date and time
  Serial.print("  Date/Time: ");
  if (gps.date.isValid()) {
    Serial.print(gps.date.day()); Serial.print("/");
    Serial.print(gps.date.month()); Serial.print("/");
    Serial.print(gps.date.year());
  } else {
    Serial.print("INVALID");
  }
  
  Serial.print(" ");
  if (gps.time.isValid()) {
    if (gps.time.hour() < 10) Serial.print("0");
    Serial.print(gps.time.hour()); Serial.print(":");
    if (gps.time.minute() < 10) Serial.print("0");
    Serial.print(gps.time.minute()); Serial.print(":");
    if (gps.time.second() < 10) Serial.print("0");
    Serial.print(gps.time.second());
  } else {
    Serial.print("INVALID");
  }

  // Satellite info
  Serial.print("  Sats: ");
  if (gps.satellites.isValid()) Serial.print(gps.satellites.value()); else Serial.print("INVALID");
  
  Serial.print("  HDOP: ");
  if (gps.hdop.isValid()) Serial.print(gps.hdop.hdop()); else Serial.print("INVALID");
  
  Serial.println();
}

// Optional function to enable NAVIC on supported GPS modules
void enableNAVIC() {
  // These are UBX commands for u-blox modules
  const uint8_t enableNAVIC1[] = {0xB5, 0x62, 0x06, 0x3E, 0x24, 0x00, 0x00, 0x00, 0x16, 0x04, 0x00, 0x04, 0xFF, 0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x01, 0x05, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x06, 0x08, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x7E, 0x3B};
  const uint8_t enableNAVIC2[] = {0xB5, 0x62, 0x06, 0x3E, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7B, 0x0A};
  
  Serial.println("Configuring GPS for NAVIC support...");
  
  for (size_t i = 0; i < sizeof(enableNAVIC1); i++) {
    gpsSerial.write(enableNAVIC1[i]);
  }
  
  delay(250);
  
  for (size_t i = 0; i < sizeof(enableNAVIC2); i++) {
    gpsSerial.write(enableNAVIC2[i]);
  }
  
  delay(250);
  Serial.println("NAVIC configuration sent");
}
.
.
.
.
.
.
/*
 * Bharat Pi GPS with NAVIC Support
 * Uses TinyGPS++ library with NAVIC satellite tracking
 * 
 * Hardware:
 * - Bharat Pi board
 * - GPS module with NAVIC support (e.g., NEO-M8N with firmware 3.01 or later)
 * 
 * Connections:
 * - GPS TX to Bharat Pi RX (GPIO16)
 * - GPS RX to Bharat Pi TX (GPIO17) - optional for configuration
 * - GPS VCC to 3.3V
 * - GPS GND to GND
 */

#include <TinyGPS++.h>
#include <HardwareSerial.h>

// Bharat Pi hardware serial pins for GPS
#define GPS_RX 16  // Connect to GPS TX
#define GPS_TX 17  // Connect to GPS RX (optional)

HardwareSerial gpsSerial(1);  // Using UART1 on Bharat Pi

TinyGPSPlus gps;

// NAVIC satellite tracking variables
uint8_t navicSats = 0;
uint8_t totalSats = 0;

void setup() {
  Serial.begin(115200);
  gpsSerial.begin(9600, SERIAL_8N1, GPS_RX, GPS_TX);
  
  Serial.println("Bharat Pi GPS with NAVIC Support");
  Serial.println("Initializing GPS...");
  
  // Optional: Configure GPS to enable NAVIC/IRNSS
  // Uncomment if your GPS module supports these commands
  // enableNAVIC();
  
  delay(1000);
}

void loop() {
  while (gpsSerial.available() > 0) {
    if (gps.encode(gpsSerial.read())) {
      displayGPSInfo();
    }
  }

  // If no valid data after 5 seconds, show warning
  if (millis() > 5000 && gps.charsProcessed() < 10) {
    Serial.println("No GPS detected - check wiring");
    while(true);
  }
}

void displayGPSInfo() {
  // Location data
  Serial.print("Location: ");
  if (gps.location.isValid()) {
    Serial.print(gps.location.lat(), 6);
    Serial.print(", ");
    Serial.print(gps.location.lng(), 6);
    Serial.print("  Altitude: ");
    if (gps.altitude.isValid()) Serial.print(gps.altitude.meters()); else Serial.print("INVALID");
  } else {
    Serial.print("INVALID");
  }

  // Date and time
  Serial.print("  Date/Time: ");
  if (gps.date.isValid()) {
    Serial.print(gps.date.day()); Serial.print("/");
    Serial.print(gps.date.month()); Serial.print("/");
    Serial.print(gps.date.year());
  } else {
    Serial.print("INVALID");
  }
  
  Serial.print(" ");
  if (gps.time.isValid()) {
    if (gps.time.hour() < 10) Serial.print("0");
    Serial.print(gps.time.hour()); Serial.print(":");
    if (gps.time.minute() < 10) Serial.print("0");
    Serial.print(gps.time.minute()); Serial.print(":");
    if (gps.time.second() < 10) Serial.print("0");
    Serial.print(gps.time.second());
  } else {
    Serial.print("INVALID");
  }

  // Satellite info with NAVIC detection
  updateSatelliteCount();
  Serial.print("  Sats: ");
  Serial.print(totalSats);
  Serial.print(" (NAVIC: ");
  Serial.print(navicSats);
  Serial.print(")  HDOP: ");
  if (gps.hdop.isValid()) Serial.print(gps.hdop.hdop()); else Serial.print("INVALID");
  
  Serial.println();
}

void updateSatelliteCount() {
  // Reset counters
  totalSats = 0;
  navicSats = 0;
  
  // Check each possible satellite ID
  for (int i = 1; i <= 255; i++) {
    if (gps.satellites.value() >= i && gps.satellite[i-1].isActive()) {
      totalSats++;
      
      // NAVIC/IRNSS satellites have PRN numbers between 1-14 (some modules)
      // Some modules report NAVIC sats with higher numbers (check your module docs)
      if (gps.satellite[i-1].id() >= 1 && gps.satellite[i-1].id() <= 14) {
        navicSats++;
      }
    }
  }
}

// Optional function to enable NAVIC on supported GPS modules
void enableNAVIC() {
  // These are UBX commands for u-blox modules
  const uint8_t enableNAVIC1[] = {0xB5, 0x62, 0x06, 0x3E, 0x24, 0x00, 0x00, 0x00, 0x16, 0x04, 0x00, 0x04, 0xFF, 0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x01, 0x05, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x06, 0x08, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x7E, 0x3B};
  const uint8_t enableNAVIC2[] = {0xB5, 0x62, 0x06, 0x3E, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7B, 0x0A};
  
  Serial.println("Configuring GPS for NAVIC support...");
  
  // Send configuration commands
  for (size_t i = 0; i < sizeof(enableNAVIC1); i++) {
    gpsSerial.write(enableNAVIC1[i]);
  }
  
  delay(250);
  
  for (size_t i = 0; i < sizeof(enableNAVIC2); i++) {
    gpsSerial.write(enableNAVIC2[i]);
  }
  
  delay(250);
  Serial.println("NAVIC configuration sent");
}
. . . . . . . . . . . . . . 
Expected O/P
................ . . . . . 
Bharat Pi GPS with NAVIC Support
Initializing GPS...
Location: 28.613939, 77.209023  Altitude: 250.50m  Date/Time: 03/04/2025 14:25:30  
Sats: 9 (NAVIC: 3)  HDOP: 1.2
Location: 28.613940, 77.209025  Altitude: 250.45m  Date/Time: 03/04/2025 14:25:35  
Sats: 10 (NAVIC: 4)  HDOP: 1.0.
.
.
.
.
.
#include <TinyGPS++.h> //Lib version compatible - 1.0.3
#include <HardwareSerial.h> //This is available from ESP32 itself not an external lib so we are good here.


#define GPS_RX_PIN 33
#define GPS_TX_PIN 32 


TinyGPSPlus gps;
HardwareSerial gpsSerial(1);


void setup() {
    Serial.begin(115200);  
    gpsSerial.begin(115200, SERIAL_8N1, GPS_RX_PIN, GPS_TX_PIN); 
    delay(5000);
    Serial.println();
    Serial.println();
    Serial.println();
    Serial.println();
    Serial.println("**********************************************************************************");
    Serial.println("  Bharat Pi NavIC Shield Test Program\n  You can use the NavIC shield on any Bharat Pi boards.\n");
    Serial.println("  Please wait while the NavIC module latches to satellites.\n");
    Serial.println("  You will notice the \"Red LED\" (PPS) on NavIC shield blinking once it latches.\n\n");
    Serial.println("  IMPORTANT: Ensure that the antenna has sky visibility and its not cloudy else it may not latch.");
    Serial.println("**********************************************************************************");
    Serial.println();
    Serial.println();
    Serial.println("  Awaiting for NavIC satellite signal latching...");
    Serial.println();
    Serial.println();
}


void loop() {
    // Read data from GPS module
    while (gpsSerial.available() > 0) {
        if (gps.encode(gpsSerial.read())) {
            if (gps.location.isValid()) {
                // Get latitude and longitude
                float latitude = gps.location.lat();
                float longitude = gps.location.lng();
                String  date = gps.date.day() + "/" + gps.date.month();
                String time = gps.time.hour() + ":" + gps.time.minute();
                double speedKnots = gps.speed.knots();
                float  courseDeg = gps.course.deg();
                double altitudeMts = gps.altitude.meters();
                uint32_t satellites = gps.satellites.value();
                double hdop = gps.hdop.hdop();

                // Print latitude and longitude, you can uncommment other parameter if you like to view those as well like date/time etc.
                Serial.print("Lat: ");
                Serial.println(latitude, 7);
                Serial.print("Long: ");
                Serial.println(longitude, 7);
                Serial.print("View lat long on Google Maps ===>>> ");
                Serial.println("http://maps.google.com/maps?q=" + String(latitude, 7) + "," + String(longitude, 7));
                // Serial.print("Date: ");
                // Serial.println(date);
                // Serial.print("Time: ");
                // Serial.println(time);
                Serial.print("Speed (knots): ");
                Serial.println(speedKnots, 7);                                                
                Serial.print("Course (degree): ");
                Serial.println(courseDeg, 7);
                Serial.print("Altitude (Meters): ");
                Serial.println(altitudeMts, 7);    
                Serial.print("Satellites:");
                Serial.println(satellites, 7);  
                Serial.print("HDOP:");
                Serial.println(hdop, 7);    
                Serial.println();
                Serial.println();                                                            
            }
        }
    }
}
. . . . . . . . . . . . . . . . . . . . . . 
**********************************************************************************
  Bharat Pi NavIC Shield Test Program
  You can use the NavIC shield on any Bharat Pi boards.

  Please wait while the NavIC module latches to satellites.

  You will notice the "Red LED" (PPS) on NavIC shield blinking once it latches.

  IMPORTANT: Ensure that the antenna has sky visibility and its not cloudy else it may not latch.
**********************************************************************************

  Awaiting for NavIC satellite signal latching...


Lat: 19.1234567
Long: 72.9876543
View lat long on Google Maps ===>>> http://maps.google.com/maps?q=19.1234567,72.9876543
Speed (knots): 0.0260000
Course (degree): 174.5200000
Altitude (Meters): 14.3200000
Satellites:7.0000000
HDOP:0.9400000


Lat: 19.1234571
Long: 72.9876550
View lat long on Google Maps ===>>> http://maps.google.com/maps?q=19.1234571,72.9876550
Speed (knots): 0.0210000
Course (degree): 175.0000000
Altitude (Meters): 14.2700000
Satellites:8.0000000
HDOP:0.9100000


.
.
.
.
.
.
.
#define TINY_GSM_MODEM_SIM7600 //TINY_GSM_MODEM compatible for 7672 as well
#define TINY_GSM_RX_BUFFER 1024

#define TINY_GSM_TEST_SMS true
#define SMS_TARGET1  "9880721666" //Enter you phone number to which you would like to recevied SMS
//You can add multiple phone number to get SMS
//#define SMS_TARGET2  "xxxxxxxxxx" //Enter you phone number to which you would like to recevied SMS
//#define SMS_TARGET3  "xxxxxxxxxx" //Enter you phone number to which you would like to recevied SMS

#define SerialAT Serial1
#define SerialMon Serial

#define GSM_PIN "" //In case if you have a password protection for your simcard

#include <WiFi.h> // Wifi client
#include <TinyGPS++.h>
#include <HardwareSerial.h>
#define GPS_RX_PIN 33
#define GPS_TX_PIN 32 

TinyGPSPlus gps;
HardwareSerial gpsSerial(2);

// Dummy variables to create a json object to push to cloud
String orgID = ""; //Suzuki
String devID = "";
String sensorName = "lat_long_1";
String secID = "";

String sensorData = "00"; 
String payload = "";

//Set APN as per your sim card:
//Airtel -> "airtelgprs.com" 
//BSNL -> "bsnlnet" 
//Voda -> portalnmms
//jio -> jionet
const char apn[]  = "airtelgprs.com"; 
const char gprsUser[] = "";
const char gprsPass[] = "";

//API/Callback url to send your data to cloud. In this example we have used 
//Pipedream which will allow to create a dummy call back URL and send data for testing purpose. 
//Create your account in Pipedream and deploy a call back URL and assign that url to this variable.
String send_data_to_url = "https://eogas6eaag50nu2.m.pipedream.net";
String gpsLatLong = ""; //Get gps lat long 
String simOperator = "";

int timeout = 60; //GPS latch timeout duration. You can increase this value based on your application/need.

#include <TinyGsmClient.h> //Library version compatible 0.12.0
#include <SPI.h> //ESP32 SPI Lib version - 2.0.16
#include <ArduinoJson.h> //Lib version - 7.0.3
#include <Ticker.h> //Lib version - 4.4.0

StaticJsonDocument<200> payloadObj; //for testing http request

#ifdef DUMP_AT_COMMANDS
  #include <StreamDebugger.h>
  StreamDebugger debugger(SerialAT, SerialMon);
  TinyGsm modem(debugger);
#else
  TinyGsm modem(SerialAT);
#endif

#define UART_BAUD   115200
#define PIN_DTR     25
#define PIN_TX      17
#define PIN_RX      16
#define PWR_PIN     32

#define LED_PIN 2

void modemPowerOn(){
  pinMode(PWR_PIN, OUTPUT);
  digitalWrite(PWR_PIN, LOW);
  delay(1000);
  digitalWrite(PWR_PIN, HIGH);
}

void modemPowerOff(){
  pinMode(PWR_PIN, OUTPUT);
  digitalWrite(PWR_PIN, LOW);
  delay(1500);
  digitalWrite(PWR_PIN, HIGH);
}

void modemRestart(){
  modemPowerOff();
  delay(1000);
  modemPowerOn();
}

void postData(String dataTobePushed) {

    digitalWrite(LED_PIN, HIGH);
    Serial.println("LED OFF"); 
    Serial.println("Cloud sync inprogress....");

    String sensorData = "{\"did\":";
    sensorData = sensorData + "\"" + devID + "\",\"oid\":";
    sensorData = sensorData + "\"" + orgID + "\",\"data\":";
    sensorData = sensorData + "[{\"data\":";
    sensorData = sensorData + "\"" + dataTobePushed + "\",\"sid\":";
    sensorData = sensorData + "\"" + sensorName + "\"}";
    sensorData = sensorData + "],\"secret\":";
    sensorData = sensorData + "\"" + secID + "\"}";

    int dataSize = sensorData.length();
    Serial.print("Device json data set to: ");
    Serial.print(sensorData);

    //Push to cloud
    httpPost(sensorData);
    Serial.println();
    digitalWrite(LED_PIN, LOW);
}

void httpPost(String data){
  Serial.println("Initiating HTTP");
  modem.sendAT("+HTTPINIT"); //init HTTP
  if (modem.waitResponse(10000L) != 1) {
    Serial.println("ERROR: HTTP INIT FAILED!");
    DBG("+HTTPINIT");
  }
  delay(2000);
  Serial.print("Payload length: ");
  Serial.println(data.length());
  Serial.println("Setting http call back URL");

  modem.sendAT("+HTTPPARA=\"URL\"," + send_data_to_url /*cloudUrl*/); //set call back URL. You can set the cloudUrl variable and uncomment to start using production. 
  if (modem.waitResponse(10000L) != 1) {
    Serial.println("ERROR: HTTP URL SETTING FAILED!");
    DBG("+HTTPPARA=\"URL\"," + send_data_to_url /*cloudUrl*/);
  }
  modem.sendAT("+HTTPPARA=\"CONTENT\",\"application/json\"");   //For test purpose we are sending plain text data. If sending json data then replace: text/plain -> application/json
  if (modem.waitResponse(10000L) != 1) {
    Serial.println("ERROR: HTTP CONTENT TYPE SETTING FAILED");
    DBG("+HTTPPARA=\"CONTENT\",\"text/plain\"");
  }
  modem.sendAT("+HTTPDATA=" + String(data.length())); //length of the body (data) and max time required in milliseconds to input the data
  //HTTPDATA responds with DOWNLOAD so need to wait for this and then send the body/data of the post call
  while (modem.waitResponse(1000UL, "DOWNLOAD") != 1) {
      Serial.print(".");
  }
  delay(2000);

  //Send the body/data of the post call
  //JSON payload or it can even be a plain text. 
  //If sending json data then format payload accordingly before sending else it might result in post error
  modem.streamWrite(data); 
  if (modem.waitResponse(10000L) != 1) {
    Serial.println("ERROR: SENDING POST DATA");
  }
  delay(2000);
  Serial.println("Executing POST call");
  modem.sendAT("+HTTPACTION=1"); //Execute post
  if (modem.waitResponse(1000UL) != 1) {
    Serial.println("ERROR: HTTP POST CALL FAILED!");
    DBG("+HTTPACTION=1");
  } else {
    Serial.print("Data sent to API: ");
    Serial.println(data);    
    Serial.print("Post call response:");
    delay(2000);
    modem.sendAT("+HTTPHEAD");
    delay(2000);
    Serial.println();
    Serial.println("Terminating HTTP");
    modem.sendAT("+HTTPTERM");
    delay(2000);
  }  
  data = "";
  sensorData = "";
}

void setup(){
  // Set console baud rate
  SerialMon.begin(115200);
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);

  delay(1000);

  WiFi.begin(); //Initialize wifi so that you can get a Mac address of the device
  devID = WiFi.macAddress(); //Set device ID
  Serial.print("Device ID set to: "); //Use device ID for tagging data to this specific device.
  Serial.println(devID);

  pinMode(GPS_TX_PIN, OUTPUT);
  pinMode(GPS_RX_PIN, OUTPUT);
  modemPowerOn();
  SerialAT.begin(UART_BAUD, SERIAL_8N1, PIN_RX, PIN_TX);
  // gpsSerial.begin(UART_BAUD, SERIAL_8N1, GPS_RX_PIN, GPS_TX_PIN); 
  Serial.clearWriteError();
  Serial.println();
  Serial.println();
  Serial.println("/**********************************************************/");
  Serial.println("  Bharat Pi 4G/LTE Board NavIC GPS Tracker Test Program");
  Serial.println("  To initialize the network test, please make sure the 4G and NavIC antenna are been");
  Serial.println("  connected and SIM card is inserted in the SIM slot (back side of the board).");
  Serial.println();
  Serial.println("  Please wait while the NavIC module latches to satellites.\n");
  Serial.println("  You will notice the \"Red LED\" (PPS) on NavIC shield blinking once it latches.\n\n");
  Serial.println("  IMPORTANT: Ensure that the antenna has sky visibility and its not cloudy else it may not latch.");
  Serial.println("/**********************************************************/\n\n");

  delay(2000);

  String res;
  Serial.println("Initializing Modem...");

  if (!modem.init()) {
    digitalWrite(LED_PIN, HIGH);
    modemRestart();
    delay(2000);
    Serial.println("Failed to restart modem, attempting to continue without restarting");
    digitalWrite(LED_PIN, LOW);
    //return;
  }

  gpsSerial.begin(UART_BAUD, SERIAL_8N1, GPS_RX_PIN, GPS_TX_PIN); 

  //Blue LED on the board use as an indicator
  //If blinking: Modem not able to boot
  //If turned ON: connected to network
  //If turned OFF: Modem booted successfully but not connected to network, check your SIM, network coverage etc.

  digitalWrite(LED_PIN, LOW); 

  Serial.println("Running SIMCOMATI command...");
  modem.sendAT("+SIMCOMATI"); //Get the module information
  modem.waitResponse(1000L, res);
  res.replace(AT_NL "OK" AT_NL, "");
  Serial.println(res);
  res = "";
  Serial.println();

  Serial.println("Preferred mode selection (GSM/LTE)...");
  modem.sendAT("+CNMP?");
  if (modem.waitResponse(1000L, res) == 1) {
    res.replace(AT_NL "OK" AT_NL, "");
    Serial.println(res);
  }
  res = "";
  Serial.println();

  //This section is only applicable for testing modules with NBIoT, 
  //for other modules the command doesnt return anything and can be ignored while testing
  Serial.println("Preferred selection between CAT-M and NB-IoT...");
  modem.sendAT("+CMNB?");
  if (modem.waitResponse(1000L, res) == 1) {
    res.replace(AT_NL "OK" AT_NL, "");
    Serial.println(res);
  }
  res = "";
  Serial.println();

  //Get module manufacturer details
  String modemName = modem.getModemModel();
  Serial.println("Modem Name : " + modemName);
  delay(1000);

  String modemInfo = modem.getModemInfo();
  Serial.println("Modem Info : " + modemInfo);
  delay(1000);

  String payload;
  payloadObj["bharat_pi_4g_module_testing"] = modemName;
  payloadObj["modemInfo"] = modemInfo;
  serializeJson(payloadObj, payload); //Convert data to json format
  //payload="Bharat Pi 4G Module Testing";

  // Unlock your SIM card with a PIN if needed (not applicable for regular sim testing)
  if ( 
    GSM_PIN && modem.getSimStatus() != 3 ) {
    modem.simUnlock(GSM_PIN);
  }

  Serial.println("Network mode connectivity testing (GSM, LTE or GSM/LTE)...");

  for (int i = 0; i <= 4; i++) {
    uint8_t network[] = {
        2,  /*Automatic*/
        13, /*GSM only*/
        38, /*LTE only*/
        51  /*GSM and LTE only*/
    };
    Serial.printf("Try %d method\n", network[i]);
    modem.setNetworkMode(network[i]);
    delay(3000);
    bool isConnected = false;
    int tryCount = 60;
    while (tryCount--) {
      String netoworkOerator = modem.getOperator();
      //Serial.pri/Users/prabhu/Downloads/FJHW1B1IGDIUPRN.inont("Operator: ");
      Serial.println(netoworkOerator);
      int16_t signal =  modem.getSignalQuality();
      Serial.print("Signal: ");
      Serial.println(signal);
      Serial.print("isNetworkConnected: ");
      isConnected = modem.isNetworkConnected();
      Serial.println( isConnected ? "CONNECTED" : "NOT CONNECTED YET");
      if (isConnected) {
        break;
      }
      delay(1000);
      digitalWrite(LED_PIN, !digitalRead(LED_PIN));
    }
    if (isConnected) {
        break;
    }
  }
  digitalWrite(LED_PIN, HIGH); //Modem connected to network

  Serial.println();
  Serial.println("Yehhh....Device is connected to Sim network.");
  Serial.println();

  delay(1000);
  Serial.println("Checking UE (User Equipment) system information...");
  Serial.println();
  modem.sendAT("+CPSI?");
  if (modem.waitResponse(1000L, res) == 1) {
    res.replace(AT_NL "OK" AT_NL, "");
    Serial.println(res);
  }

  delay(1000);  
  Serial.println("");
  Serial.println("");

  if(modem.isNetworkConnected()){
    Serial.println("Mobile Network is connected.......");
  }  
  // GPRS connection parameters are usually set after network registration
  SerialMon.print(F("DATA Connection Details: \nConnecting to APN: "));
  SerialMon.println(apn);
  if (!modem.gprsConnect(apn, "", "")) {
    Serial.println("APN connect failed");
    delay(10000);
    return;
  }
  Serial.println("APN connect success");

  if (modem.isGprsConnected()) { 
    Serial.println("");
    Serial.println("GPRS network is connected");
  }
  Serial.println("");    

  //Get SIM operator name
  modem.sendAT("+CSPN?");
  if (modem.waitResponse(1000L, simOperator) == 1) {
    res.replace(AT_NL "OK" AT_NL, "");
    Serial.print("Sim Operator: ");
    Serial.println(simOperator);
  }
  Serial.println();  

  delay(2000);
  Serial.println("Testing the a sample HTTPS Call to pipe drive server...");
  Serial.println("NOTE: Please ensure to deploy an end point on Pipe Dream (pipedream.com) to test. Example: " + send_data_to_url);
  Serial.println();
  Serial.println();
  Serial.println("MODEM TESTING IN PROGRESS....");
  Serial.println();
  delay(5000);
  Serial.println("Initiating HTTP");
  modem.sendAT("+HTTPINIT"); //init HTTP
  if (modem.waitResponse(10000L) != 1) {
    Serial.println("ERROR: HTTP INIT FAILED!");
    DBG("+HTTPINIT");
  }
  delay(5000);
  Serial.print("Paylog length: ");
  Serial.println(payload.length());
  Serial.println("Setting http call back URL");

  //modem.sendAT("+HTTPPARA=\"URL\",https://eogas6eaag50nu2.m.pipedream.net"); //set call back URL to test 
  modem.sendAT("+HTTPPARA=\"URL\"," + send_data_to_url); //set call back URL to test 
  if (modem.waitResponse(10000L) != 1) {
    Serial.println("ERROR: HTTP URL SETTING FAILED!");
    DBG("+HTTPPARA=\"URL\"," + send_data_to_url);
  }
  modem.sendAT("+HTTPPARA=\"CONTENT\",\"text/plain\"");   //For test purpose we are sending plain text data. If sending json data then replace: text/plain -> application/json
  if (modem.waitResponse(10000L) != 1) {
    Serial.println("ERROR: HTTP CONTENT TYPE SETTING FAILED");
    DBG("+HTTPPARA=\"CONTENT\",\"text/plain\"");
  }
  modem.sendAT("+HTTPDATA=" + String(payload.length())); //length of the body (data) and max time required in milliseconds to input the data
  //HTTPDATA responds with DOWNLOAD so need to wait for this and then send the body/data of the post call
  // while (modem.waitResponse(1000UL, "DOWNLOAD") != 1) {
  //     Serial.print(".");
  // }
  if (modem.waitResponse(10000L) != 1) {
    Serial.println("ERROR: HTTP DATA SETTING FAILED");
    DBG("+HTTPDATA=" + String(payload.length()));
  }  
  delay(2000);

  //Send the body/data of the post call
  //JSON payload or it can even be a plain text. 
  //If sending json data then format payload accordingly before sending else it might result in post error
  modem.streamWrite(payload); 
  if (modem.waitResponse(10000L) != 1) {
    Serial.println("ERROR: SENDING POST DATA");
  }
  delay(2000);
  Serial.println("Executing POST call");
  modem.sendAT("+HTTPACTION=1"); //Execute post
  if (modem.waitResponse(1000UL) != 1) {
    Serial.println("ERROR: HTTP POST CALL FAILED!");
    DBG("+HTTPACTION=1");
  } else {
    Serial.print("Data sent to API: ");
    Serial.println(payload);    
    Serial.print("Post call response:");
    delay(2000);
    modem.sendAT("+HTTPHEAD");
    delay(2000);
    Serial.println();
    Serial.println("Terminating HTTP");
    modem.sendAT("+HTTPTERM");
    delay(2000);
  }

  Serial.println("Sending Test SMS to number(s):");
  Serial.println(SMS_TARGET1);
  
  //Uncomment below to print if you have set more than one phone numbers
  //Serial.println(SMS_TARGET2);
  //Serial.println(SMS_TARGET3);

  #if TINY_GSM_TEST_SMS && defined TINY_GSM_MODEM_HAS_SMS && defined SMS_TARGET1 
    res = modem.sendSMS(SMS_TARGET1, String(modemInfo));
    DBG("SMS sent status:", res ? "SUCCESS" : "FAILED");
    delay(2000);

    //Uncomment below code if you wish to send SMS to more than one number. 
    // res = modem.sendSMS(SMS_TARGET2, String("Hello from Bharat Pi! Board is working."));
    // DBG("SMS sent status:", res ? "SUCCESS" : "FAILED");
    // delay(2000);

    // res = modem.sendSMS(SMS_TARGET3, String("Hello from Bharat Pi! Board is working."));
    // DBG("SMS sent status:", res ? "SUCCESS" : "FAILED");
    // delay(2000);
  #endif
  Serial.println(">>>>> End of 4G Modem Testing <<<<<<");
  Serial.println();
  Serial.println();
  Serial.println("Awaiting NavIC GPS Tracker latching");
  Serial.println();
  Serial.println();
}


void loop(){
  while (gpsSerial.available() > 0) {
    if (gps.encode(gpsSerial.read())) {
      if (gps.location.isValid()) {
        // Get latitude and longitude
        float latitude = gps.location.lat();
        float longitude = gps.location.lng();
        String  date = gps.date.day() + "/" + gps.date.month();
        String time = gps.time.hour() + ":" + gps.time.minute();
        double speedKnots = gps.speed.knots();
        float  courseDeg = gps.course.deg();
        double altitudeMts = gps.altitude.meters();
        uint32_t satellites = gps.satellites.value();
        double hdop = gps.hdop.hdop();

        // Print latitude and longitude, you can uncommment other parameter if you like to view those as well like date/time etc.
        Serial.print("Lat: ");
        Serial.println(latitude, 7);
        Serial.print("Long: ");
        Serial.println(longitude, 7);
        Serial.print("View lat long on Google Maps ===>>> ");
        Serial.println("http://maps.google.com/maps?q=" + String(latitude, 7) + "," + String(longitude, 7));
        // Serial.print("Date: ");
        // Serial.println(date);
        // Serial.print("Time: ");
        // Serial.println(time);
        Serial.print("Speed (knots): ");
        Serial.println(speedKnots, 7);                                                
        Serial.print("Course (degree): ");
        Serial.println(courseDeg, 7);
        Serial.print("Altitude (Meters): ");
        Serial.println(altitudeMts, 7);    
        Serial.print("Satellites:");
        Serial.println(satellites, 7);  
        Serial.print("HDOP:");
        Serial.println(hdop, 7);    
        Serial.println();
        Serial.println();      
        Serial.print("Pushing NavIC lat long data to cloud....");     
        delay(2000);
        postData(String(latitude, 7) + "," + String(longitude, 7)); //You can create a json object with all the NavIC data and push to cloud
        delay(2000);
        //Send Lat long as SMS 
        #if TINY_GSM_TEST_SMS && defined TINY_GSM_MODEM_HAS_SMS && defined SMS_TARGET1 
          bool resp = modem.sendSMS(SMS_TARGET1, "Bharat Pi NavIC GPS Tracker.\n\nLat:" + String(latitude, 7) + "\nLong:" + String(longitude, 7));
          DBG("SMS sent status:", resp ? "SUCCESS" : "FAILED");
          delay(2000);
        #endif

        delay(30000); //Push lat long to cloud every 10 seconds
      } else {
        Serial.print(".");
        delay(2000);
      }
    }
  }  
}
.
.
.
.
.
#include <Wire.h>
#include <TinyGPS++.h>
#include <HardwareSerial.h>
#include <SoftwareSerial.h>
#include <Arduino.h>
#include <string.h>
#include "utilities.h"
#include "Modem.h"
#include "network.h"
#include "certs.h"

// Define GPS Serial (NavIC)
HardwareSerial gpsSerial(2);  // UART2: RX2 (GPIO16), TX2 (GPIO17)
TinyGPSPlus gps;

String gpsLatLong = "0,0";

// Define LED GPIOs (optional indicators)
#define LED_NETWORK 4
#define LED_GPS 5
#define LED_TX 2
#define LED_RX 15

String send_data_to_url = "https://eouq22kqtulhrx9.m.pipedream.net/";

// Initialize modem
Modem modem;
bool modemStatus = false;

// Function to send data
void postData(String gpsData) {
  Serial.println("Starting HTTPS POST...");

  String post_data = "{\"gps\": \"" + gpsData + "\"}";
  int post_data_len = post_data.length();

  Serial.print("POST data: ");
  Serial.println(post_data);

  // Setup HTTP
  modem.sendAT("+HTTPINIT");
  delay(1000);

  modem.sendAT("+HTTPPARA=\"CID\",1");
  delay(500);

  modem.sendAT("+HTTPPARA=\"URL\",\"" + send_data_to_url + "\"");
  delay(500);

  modem.sendAT("+HTTPPARA=\"CONTENT\",\"application/json\"");
  delay(500);

  modem.sendAT("+HTTPDATA=" + String(post_data_len) + ",10000");
  delay(1000);

  modem.print(post_data);
  delay(1500);

  modem.sendAT("+HTTPACTION=1");  // POST
  delay(5000);

  modem.sendAT("+HTTPTERM");
  delay(1000);

  Serial.println("POST complete.");
}

// Setup
void setup() {
  Serial.begin(115200);
  gpsSerial.begin(9600, SERIAL_8N1, 33, 32);  // RX=33, TX=32 for GPS

  pinMode(LED_NETWORK, OUTPUT);
  pinMode(LED_GPS, OUTPUT);
  pinMode(LED_TX, OUTPUT);
  pinMode(LED_RX, OUTPUT);

  digitalWrite(LED_NETWORK, LOW);
  digitalWrite(LED_GPS, LOW);

  delay(3000);

  // Setup modem and network
  modemStatus = modem.begin();
  if (!modemStatus) {
    Serial.println("Modem not responding. Restarting...");
    delay(10000);
    ESP.restart();
  }

  Serial.println("Modem ready.");

  digitalWrite(LED_NETWORK, HIGH);

  // Attach GPRS
  Serial.println("Attaching GPRS...");
  if (!modem.gprsConnect(APN, "", "")) {
    Serial.println("GPRS attach failed!");
    delay(10000);
    ESP.restart();
  }

  Serial.println("GPRS attached.");
  Serial.println("Setup complete.");
}

// Main loop
void loop() {
  // Feed GPS data
  while (gpsSerial.available()) {
    gps.encode(gpsSerial.read());
  }

  static unsigned long lastSend = 0;
  if (millis() - lastSend > 30000) {
    lastSend = millis();

    if (gps.location.isValid() && gps.location.age() < 2000) {
      double lat = gps.location.lat();
      double lng = gps.location.lng();
      gpsLatLong = String(lat, 6) + "," + String(lng, 6);

      Serial.print("GPS Location: ");
      Serial.println(gpsLatLong);

      digitalWrite(LED_GPS, HIGH);
      postData(gpsLatLong);
      digitalWrite(LED_GPS, LOW);
    } else {
      Serial.println("Waiting for valid GPS fix...");
    }
  }
}

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
‚úÖ What's Fixed/Improved
Fixed sendAT("+HTTPPARA=\"URL\"," + send_data_to_url); ‚Üí now correctly wrapped in quotes.

Added loop() to send GPS data every 30 seconds.

Added GPS data validation (isValid() and age() check).

Cleaned up LED status use for debugging.

Let me know if you want to include extra data (e.g. IMEI, signal strength, battery) or want to add SMS functionality

Serial Monitor Output

Modem ready.
Attaching GPRS...
GPRS attached.
Setup complete.
Waiting for valid GPS fix...
Waiting for valid GPS fix...
GPS Location: 19.123456,72.987654
Starting HTTPS POST...
POST data: {"gps": "19.123456,72.987654"}
POST complete.

Waiting for valid GPS fix...
GPS Location: 19.123457,72.987655
Starting HTTPS POST...
POST data: {"gps": "19.123457,72.987655"}
POST complete.



‚úÖ Example Data Received on Pipedream
Your endpoint https://eouq22kqtulhrx9.m.pipedream.net/ will receive POST requests like this:

json
Copy
Edit
{
  "gps": "19.123456,72.987654"
}
Every 30 seconds (if GPS fix is valid), a new POST is sent with the latest coordinates.
.
.
.
.
.
.
.
.
.
.
.
.
#include <TinyGPS++.h>
#include <HardwareSerial.h>

#define GPS_RX_PIN 33
#define GPS_TX_PIN 32

#define SIM_RX_PIN 26  // SIM Module TX ‚Üí ESP32 RX
#define SIM_TX_PIN 27  // SIM Module RX ‚Üí ESP32 TX

const char* phoneNumber = "+91XXXXXXXXXX";  // Replace with your number

TinyGPSPlus gps;
HardwareSerial gpsSerial(1);  // GPS
HardwareSerial simSerial(2);  // SIM Module

void setup() {
  Serial.begin(115200);
  gpsSerial.begin(115200, SERIAL_8N1, GPS_RX_PIN, GPS_TX_PIN);  // GPS
  simSerial.begin(9600, SERIAL_8N1, SIM_RX_PIN, SIM_TX_PIN);    // SIM
  
  delay(3000);
  Serial.println("Waiting for GPS signal...");
}

void loop() {
  while (gpsSerial.available() > 0) {
    if (gps.encode(gpsSerial.read())) {
      if (gps.location.isValid()) {
        float lat = gps.location.lat();
        float lng = gps.location.lng();

        Serial.println("Location acquired!");
        Serial.print("Latitude: "); Serial.println(lat, 7);
        Serial.print("Longitude: "); Serial.println(lng, 7);

        String smsMessage = "GPS Location:\nLat: " + String(lat, 7) + "\nLong: " + String(lng, 7) + 
                            "\nMap: http://maps.google.com/maps?q=" + String(lat, 7) + "," + String(lng, 7);

        sendSMS(phoneNumber, smsMessage);

        // Wait before sending again
        delay(60000);  // 1 minute delay
      }
    }
  }
}

void sendSMS(const char* number, const String& message) {
  Serial.println("Sending SMS...");
  
  simSerial.println("AT");
  delay(500);
  simSerial.println("AT+CMGF=1"); // Set SMS mode to text
  delay(500);
  simSerial.print("AT+CMGS=\"");
  simSerial.print(number);
  simSerial.println("\"");
  delay(1000);
  simSerial.print(message);
  simSerial.write(26);  // ASCII code for CTRL+Z to send SMS
  delay(5000);
  
  Serial.println("SMS Sent!");
}
. . . . . . . . . .. . . . . . . . .... . . 

Location acquired!
Latitude: 19.0760900
Longitude: 72.8774260
Sending SMS...
SMS Sent!

GPS Location:
Lat: 19.0760900
Long: 72.8774260
Map: http://maps.google.com/maps?q=19.0760900,72.8774260



